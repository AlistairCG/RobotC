#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  rightIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftIEM,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex269_HBridge, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex269_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main
{
wait1Msec(2000);

//Setup the VEX LCD for displaying encoder values
clearLCDLine(0);
clearLCDLine(1);
displayLCDString(0, 0, "R: ");
displayLCDString(1, 0, "L: ");

//Clear the encoders associated with the left and right motors
nMotorEncoder[rightMotor] = 0;
nMotorEncoder[leftMotor] = 0;

//While less than 1000 encoder counts of the right motor
while( nMotorEncoder[rightMotor] < 7300)
{
motor[rightMotor] = 120;
motor[leftMotor]  = 120;
}
//Clear the encoders associated with the left and right motors
motor[leftMotor] = 0;
motor[rightMotor] = 0;
wait1Msec(2000);
nMotorEncoder[rightMotor] = 0;
nMotorEncoder[leftMotor] = 0;

while( nMotorEncoder[leftMotor] < 1000)
{
//Display the right and left motor encoder values
displayLCDNumber(0, 3, nMotorEncoder[rightMotor], 6);
//displayLCDNumber(1, 3, nMotorEncoder[leftMotor], 6);
//Move forward at half power
motor[rightMotor]  = 63;
}

//Clear the encoders associated with the left and right motors
motor[leftMotor] = 0;
motor[rightMotor] = 0;
wait1Msec(2000);
nMotorEncoder[rightMotor] = 0;
nMotorEncoder[leftMotor] = 0;

while( nMotorEncoder[rightMotor] < 10000)
{
//Display the right and left motor encoder values
displayLCDNumber(0, 3, nMotorEncoder[rightMotor], 6);
//displayLCDNumber(1, 3, nMotorEncoder[leftMotor], 6);
//Move forward at half power
motor[rightMotor] = 63;
motor[leftMotor]  = 63;
}
motor[leftMotor] = 0;
motor[rightMotor] = 0;


}
